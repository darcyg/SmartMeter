###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         29/Oct/2014  21:28:47
# Copyright 1996-2014 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for Texas Instruments MSP430, Evaluation Version 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        D:\Documents\GitHub\SmartMeter\Source\emeter-ng\emeter-foreground.c
#    Command line  =  
#        D:\Documents\GitHub\SmartMeter\Source\emeter-ng\emeter-foreground.c -D
#        "CUSTOM_EMETER_H=\"emeter-1ph-neutral-6733_shunt.h\"" -D X_ZEBU_ -lcN
#        D:\Documents\GitHub\SmartMeter\Source\emeter-ng\Debug\List\ -o
#        D:\Documents\GitHub\SmartMeter\Source\emeter-ng\Debug\Obj\ --debug
#        -D__MSP430F6736__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\430\lib\dlib\dl430xlsfn.h" -I
#        D:\Documents\GitHub\SmartMeter\Source\emeter-ng/../emeter-toolkit\
#        --core=430X --data_model=small -Ohs --multiplier=32
#        --multiplier_location=4C0 --hw_workaround=CPU40 --hw_workaround=CPU39
#        --code_model=large
#    List file     =  
#        D:\Documents\GitHub\SmartMeter\Source\emeter-ng\Debug\List\emeter-foreground.lst
#    Object file   =  
#        D:\Documents\GitHub\SmartMeter\Source\emeter-ng\Debug\Obj\emeter-foreground.r43
#
###############################################################################

D:\Documents\GitHub\SmartMeter\Source\emeter-ng\emeter-foreground.c
      1          //--------------------------------------------------------------------------
      2          //
      3          //  Software for MSP430 based e-meters.
      4          //
      5          //  THIS PROGRAM IS PROVIDED "AS IS". TI MAKES NO WARRANTIES OR
      6          //  REPRESENTATIONS, EITHER EXPRESS, IMPLIED OR STATUTORY,
      7          //  INCLUDING ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
      8          //  FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR
      9          //  COMPLETENESS OF RESPONSES, RESULTS AND LACK OF NEGLIGENCE.
     10          //  TI DISCLAIMS ANY WARRANTY OF TITLE, QUIET ENJOYMENT, QUIET
     11          //  POSSESSION, AND NON-INFRINGEMENT OF ANY THIRD PARTY
     12          //  INTELLECTUAL PROPERTY RIGHTS WITH REGARD TO THE PROGRAM OR
     13          //  YOUR USE OF THE PROGRAM.
     14          //
     15          //  IN NO EVENT SHALL TI BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
     16          //  CONSEQUENTIAL OR INDIRECT DAMAGES, HOWEVER CAUSED, ON ANY
     17          //  THEORY OF LIABILITY AND WHETHER OR NOT TI HAS BEEN ADVISED
     18          //  OF THE POSSIBILITY OF SUCH DAMAGES, ARISING IN ANY WAY OUT
     19          //  OF THIS AGREEMENT, THE PROGRAM, OR YOUR USE OF THE PROGRAM.
     20          //  EXCLUDED DAMAGES INCLUDE, BUT ARE NOT LIMITED TO, COST OF
     21          //  REMOVAL OR REINSTALLATION, COMPUTER TIME, LABOR COSTS, LOSS
     22          //  OF GOODWILL, LOSS OF PROFITS, LOSS OF SAVINGS, OR LOSS OF
     23          //  USE OR INTERRUPTION OF BUSINESS. IN NO EVENT WILL TI'S
     24          //  AGGREGATE LIABILITY UNDER THIS AGREEMENT OR ARISING OUT OF
     25          //  YOUR USE OF THE PROGRAM EXCEED FIVE HUNDRED DOLLARS
     26          //  (U.S.$500).
     27          //
     28          //  Unless otherwise stated, the Program written and copyrighted
     29          //  by Texas Instruments is distributed as "freeware".  You may,
     30          //  only under TI's copyright in the Program, use and modify the
     31          //  Program without any charge or restriction.  You may
     32          //  distribute to third parties, provided that you transfer a
     33          //  copy of this license to the third party and the third party
     34          //  agrees to these terms by its first use of the Program. You
     35          //  must reproduce the copyright notice and any other legend of
     36          //  ownership on each copy or partial copy, of the Program.
     37          //
     38          //  You acknowledge and agree that the Program contains
     39          //  copyrighted material, trade secrets and other TI proprietary
     40          //  information and is protected by copyright laws,
     41          //  international copyright treaties, and trade secret laws, as
     42          //  well as other intellectual property laws.  To protect TI's
     43          //  rights in the Program, you agree not to decompile, reverse
     44          //  engineer, disassemble or otherwise translate any object code
     45          //  versions of the Program to a human-readable form.  You agree
     46          //  that in no event will you alter, remove or destroy any
     47          //  copyright notice included in the Program.  TI reserves all
     48          //  rights not specifically granted under this license. Except
     49          //  as specifically provided herein, nothing in this agreement
     50          //  shall be construed as conferring by implication, estoppel,
     51          //  or otherwise, upon you, any license or other right under any
     52          //  TI patents, copyrights or trade secrets.
     53          //
     54          //  You may not use the Program in non-TI devices.
     55          //
     56          //  File: emeter-foreground.c
     57          //
     58          //  Steve Underwood <steve-underwood@ti.com>
     59          //  Texas Instruments Hong Kong Ltd.
     60          //
     61          //  $Id: emeter-foreground.c,v 1.43 2009/04/27 09:05:26 a0754793 Exp $
     62          //
     63          /*! \file emeter-structs.h */
     64          //
     65          //--------------------------------------------------------------------------
     66          //
     67          //  MSP430 foreground (non-interrupt) routines for e-meters
     68          //
     69          //  This software is appropriate for single phase and three phase e-meters
     70          //  using a voltage sensor plus a CT or shunt resistor current sensors, or
     71          //  a combination of a CT plus a shunt.
     72          //
     73          //    Foreground process includes:
     74          //    -Using timer tick to wait
     75          //    -Calculating the power per channel
     76          //    -Determine if current channel needs scaling.
     77          //    -Determine if needs to be in low power modes.
     78          //    -Compensate reference from temperature sensor
     79          //
     80          #include <stdint.h>
     81          #include <stdlib.h>
     82          #if !defined(__MSP430__)
     83          #include <stdio.h>
     84          #include <fcntl.h>
     85          #include <unistd.h>
     86          #endif
     87          #if defined(__GNUC__)
     88          #include <signal.h>
     89          #endif
     90          #include <math.h>
     91          #include <io.h>
     92          #include <emeter-toolkit.h>
     93          #define __MAIN_PROGRAM__
     94          
     95          #include "emeter-structs.h"
     96          #if defined(MESH_NET_SUPPORT)
     97          #include "mesh_structure.h"
     98          #endif
     99          
    100          int32_t xxx;
    101          int32_t yyy;
    102          
    103          #if !defined(__IAR_SYSTEMS_ICC__)
    104          static __inline__ long labs(long __x);
    105          
    106          static __inline__ long labs(long __x)
    107          {
    108              return (__x < 0) ? -__x : __x;
    109          }
    110          #endif
    111          
    112            void set_phase_correction(struct phase_correction_s *s, int correction)
    113            {
    114                correction += 128;
    115            ////#if defined(__HAS_SD_ADC__)
    116            ////    s->step = (correction >> 8) + I_HISTORY_STEPS*2 + 1;
    117            ////#else
    118                s->step = I_HISTORY_STEPS + (correction >> 8);
    119            ////#endif
    120                correction = 127 - ((correction & 0xFF) >> 1);
    121                s->fir_beta = fir_coeffs[correction][0];
    122                s->fir_gain = fir_coeffs[correction][1];
    123            }
    124          
    125          #if defined(DYNAMIC_PHASE_CORRECTION_SUPPORT)
    126          static void set_phase_gain_correction(struct phase_correction_s *s, int correction, int gain)
    127          {
    128              correction += 128;
    129              s->step = I_HISTORY_STEPS + (correction >> 8);
    130              correction = 127 - ((correction & 0xFF) >> 1);
    131              s->fir_beta = fir_coeffs[correction][0];
    132              s->fir_gain = Q1_15_mul(gain, fir_coeffs[correction][1]);
    133          }
    134          #endif
    135          
    136          #if defined(__HAS_SD_ADC__)
    137          void set_sd16_phase_correction(struct phase_correction_sd16_s *s, int ph, int correction)
    138          {
    139            #if defined(__MSP430_HAS_SD24_B__)
    140              static unsigned short volatile * const sd16_locations[NUM_CURRENT_CHANNELS] =
    141            #else
    142              static unsigned char volatile * const sd16_locations[NUM_CURRENT_CHANNELS] =
    143            #endif      
    144              {
    145              #if defined(SINGLE_PHASE)
    146                  &SD16PRE_LIVE,
    147              #else
    148                  &SD16PRE_CURRENT_1,
    149                  &SD16PRE_CURRENT_2,
    150                  &SD16PRE_CURRENT_3,
    151              #endif
    152              #if defined(NEUTRAL_MONITOR_SUPPORT)
    153                  &SD16PRE_NEUTRAL
    154              #endif
    155              };
    156              uint8_t bump;
    157          
    158              /* Only try to nudge the converter's timing when in normal operating mode. */
    159              if (operating_mode == OPERATING_MODE_NORMAL)
    160              {
    161                // [HOTFIX RO] Take the larger size of the preload register into account
    162                //  if ((bump = s->sd16_preloaded_offset - (correction & 0xFF)))
    163                      if ((bump = s->sd16_preloaded_offset - (correction & 0xFF)))
    164                // [END HOTFIX RO]        
    165                      *sd16_locations[ph] = bump;
    166              }
    167              /* Always store the required correction. */
    168              s->step = I_HISTORY_STEPS - (correction >> 8);
    169          ////    s->step = (correction >> 8) - I_HISTORY_STEPS + 1;
    170              s->sd16_preloaded_offset = correction;
    171          }
    172          #endif
    173          
    174          #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)  &&  defined(POWER_BALANCE_DETECTION_SUPPORT)
    175          static int32_t test_phase_balance(int32_t live_signal, int32_t neutral_signal, int threshold)
    176          {
    177              int permitted_imbalance_fraction;
    178          
    179              /* This may be testing between two currents, or between two powers. I normal mode it
    180                 is testing between two power readings. In limp mode it is testing between two
    181                 current readings. */
    182              /* See which one is bigger, with some tolerance built in. If the signal measured
    183                 from the neutral is more than 6.25% or 12.5% (options) different from the signal
    184                 measured from the live there is something wrong (maybe fraudulent tampering, or
    185                 just something faulty). In this case we use the current measured from the
    186                 channel with the higher signal. When the channel is reasonably balanced, we use
    187                 the signal from the live lead. If neither signal is above the threshold we use
    188                 a more relaxed measure of imbalance (say 25% or even 50%), to allow for the lower
    189                 accuracy of these small signals (remember, we need the test to work well under
    190                 transient conditions, so the threshold needs to be far more relaxed than the
    191                 basic measurement accuracy would indicate). Assessments are persistence checked
    192                 to avoid transient conditions causing a false change of imbalance status. */
    193              if (live_signal <= threshold  &&  neutral_signal <= threshold)
    194                  permitted_imbalance_fraction = RELAXED_IMBALANCE_FRACTION;
    195              else
    196                  permitted_imbalance_fraction = PERMITTED_IMBALANCE_FRACTION;
    197              /* We have a signal strong enough for proper assessment. */
    198              if ((phase->status & PHASE_UNBALANCED))
    199              {
    200                  /* We are looking for the restoration of balance between the
    201                     live and neutral. */
    202                  if ((live_signal - (live_signal >> permitted_imbalance_fraction)) < neutral_signal
    203                      &&
    204                      neutral_signal < (live_signal + (live_signal >> permitted_imbalance_fraction)))
    205                  {
    206                      /* Things might be balanced, but persistence check to be sure. */
    207                      if (--current_unbalanced <= -PHASE_UNBALANCED_PERSISTENCE_CHECK)
    208                      {
    209                          /* Things look genuinely balanced. */
    210                          phase->status &= ~(PHASE_UNBALANCED | CURRENT_FROM_NEUTRAL);
    211                          current_unbalanced = 0;
    212                      }
    213                  }
    214                  else
    215                  {
    216                      current_unbalanced = 0;
    217                      /* The imbalanced might have swapped around - check. */
    218                      /* Here we just choose the greater signal each block, as we have
    219                          already confirmed (i.e. debounced) the imbalance condition. */
    220                      if (neutral_signal > live_signal)
    221                          phase->status |= CURRENT_FROM_NEUTRAL;
    222                      else
    223                          phase->status &= ~CURRENT_FROM_NEUTRAL;
    224                  }
    225              }
    226              else
    227              {
    228                  /* We are looking for the live and neutral becoming unbalanced. */
    229                  if ((live_signal - (live_signal >> permitted_imbalance_fraction)) > neutral_signal
    230                      ||
    231                      neutral_signal > (live_signal + (live_signal >> permitted_imbalance_fraction)))
    232                  {
    233                      /* Things might be unbalanced, but persistence check to be sure. */
    234                      if (++current_unbalanced >= PHASE_UNBALANCED_PERSISTENCE_CHECK)
    235                      {
    236                          /* Things look genuinely unbalanced. */
    237                          current_unbalanced = 0;
    238                          phase->status |= PHASE_UNBALANCED;
    239                          if (neutral_signal > live_signal)
    240                              phase->status |= CURRENT_FROM_NEUTRAL;
    241                          else
    242                              phase->status &= ~CURRENT_FROM_NEUTRAL;
    243                      }
    244                  }
    245                  else
    246                  {
    247                      current_unbalanced = 0;
    248                  }
    249              }
    250              /* Clear the unbalanced detection, so we don't display unbalanced. This should eliminate
    251                 flashing of the LED if the are transient conditions causing false indications of
    252                 imbalance. */
    253              if (live_signal <= threshold  &&  neutral_signal <= threshold)
    254                  phase->status &= ~PHASE_UNBALANCED;
    255              if ((phase->status & CURRENT_FROM_NEUTRAL))
    256                  return  neutral_signal;
    257              return  live_signal;
    258          }
    259          #endif
    260          
    261          #if defined(MAINS_FREQUENCY_SUPPORT)
    262          #if defined(SINGLE_PHASE)
    263          int16_t frequency(void)
    264          #else
    265          int16_t frequency(struct phase_parms_s *phase, struct phase_nv_parms_s const *phase_nv)
    266          #endif
    267          {
    268              int32_t x;
    269              //int step;
    270              //int offset;
    271          
    272              /* Calculate the mains frequency in 1/100Hz increments, based on the mains
    273                 period assessment from the background activity. */
    274          #if defined(LIMP_MODE_SUPPORT)
    275              if (operating_mode == OPERATING_MODE_LIMP)
    276              {
    277                  /* In limp mode there is no voltage waveform, so we get the frequency from
    278                     the current in the active lead. This may fail to measure frequency
    279                     correctly for very low currents, and very distorted current waveforms. */
    280              #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    281                  if ((phase->status & CURRENT_FROM_NEUTRAL))
    282                      x = phase->metrology.neutral.mains_period;
    283                  else
    284              #endif
    285                      x = phase->metrology.current.mains_period;
    286              }
    287              else
    288              {
    289          #endif
    290                  /* Normally we get the mains frequency from the voltage. Voltage is always
    291                     present, and is not subject to the same level of distortion as the current
    292                     waveform with difficult loads. */
    293                
    294          #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    295                  /* We have a whole cycle period in the upper 16 bits, but we want the delay for 90 degrees, so we shift 2
    296                     extra bits for that. */
    297                  x = (phase->metrology.mains_period >> 18);
    298              #if defined(__HAS_SD_ADC__)
    299                  set_phase_correction(&phase->metrology.current.quadrature_correction[0], x);
    300                  #if GAIN_STAGES > 1
    301                  set_phase_correction(&phase->metrology.current.quadrature_correction[1], x);
    302                  #endif
    303              #else
    304                  set_phase_correction(&phase->metrology.current.quadrature_correction[0], x + phase_nv->current.phase_correction[0]);
    305                  #if GAIN_STAGES > 1
    306                  set_phase_correction(&phase->metrology.current.quadrature_correction[1], x + phase_nv->current.phase_correction[1]);
    307                  #endif
    308              #endif
    309              #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    310                  #if defined(__HAS_SD_ADC__)
    311                  set_phase_correction(&phase->metrology.neutral.quadrature_correction[0], x);
    312                      #if GAIN_STAGES > 1
    313                  set_phase_correction(&phase->metrology.neutral.quadrature_correction[1], x);
    314                      #endif
    315                  #else
    316                  set_phase_correction(&phase->metrology.neutral.quadrature_correction[0], x + nv_parms.seg_a.s.neutral.phase_correction[0]);
    317                      #if GAIN_STAGES > 1
    318                  set_phase_correction(&phase->metrology.neutral.quadrature_correction[1], x + nv_parms.seg_a.s.neutral.phase_correction[1]);
    319                      #endif
    320                  #endif
    321              #endif
    322          #endif
    323          
    324                  
    325                  
    326                  x = phase->metrology.mains_period;
    327          #if defined(LIMP_MODE_SUPPORT)
    328              }
    329          #endif
    330              x = (int32_t) SAMPLES_PER_10_SECONDS*256L*10L/(x >> 16);
    331              return  x;
    332          }
    333          #endif
    334          
    335          #if defined(VRMS_SUPPORT)
    336              #if defined(SINGLE_PHASE)
    337          int32_t voltage(void)
    338              #else
    339          int32_t voltage(struct phase_parms_s *phase, struct phase_nv_parms_s const *phase_nv)
    340              #endif
    341          {
    342              int16_t i;
    343              int32_t x;
    344          
    345              /* Calculate the RMS voltage in 10mV increments. Return -1 for overrange
    346                 (i.e. ADC clip). */
    347              if ((phase->status & V_OVERRANGE))
    348                  return -1;
    349              x = div_sh48(phase->metrology.dot_prod_logged.V_sq, 26 - 2*ADC_BITS, phase->metrology.dot_prod_logged.sample_count);
    350              #if defined(LIMP_MODE_SUPPORT)
    351              if (operating_mode == OPERATING_MODE_LIMP)
    352                  i = phase_nv->V_rms_limp_scale_factor;
    353              else
    354              #endif
    355                  i = phase_nv->V_rms_scale_factor;
    356              x = isqrt32(x);
    357              x = (x >> 12)*i;
    358              x >>= 14;
    359              return x;
    360          }
    361          #endif
    362          
    363          #if defined(IRMS_SUPPORT)
    364              #if defined(SINGLE_PHASE)
    365          rms_current_t current(void)
    366              #else
    367          rms_current_t current(struct phase_parms_s *phase, struct phase_nv_parms_s const *phase_nv, int ph)
    368          #endif
    369          {
    370              int16_t i;
    371              rms_current_t x;
    372              #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    373              rms_current_t y;
    374              #endif
    375              #if defined(TWENTYFOUR_BIT)
    376              int64_t tmp;
    377              #else
    378              int32_t tmp;
    379              #endif
    380          
    381              /* Calculate the RMS current in 1mA increments. Return -1 for overrange
    382                 (i.e. ADC clip). A side effect of this routine is it updates the dynamic
    383                 phase correction settings, based on the newly calculated current. */
    384              /* We always have to work out the properly scaled current from both leads, in
    385                 order to work out the FIR coeffs for the next block. */
    386              #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    387              if ((phase->status & I_NEUTRAL_OVERRANGE))
    388              {
    389                  y = (rms_current_t) ~0;
    390              }
    391              else
    392              {
    393                  test64=tmp = div_ac_current(phase->metrology.neutral.dot_prod_logged.I_sq, phase->metrology.neutral.dot_prod_logged.sample_count);
    394                  if (tmp < phase_nv->current.ac_offset)
    395                  {
    396                      y = 0;
    397                  }
    398                  else
    399                  {
    400                      tmp -= phase_nv->neutral.ac_offset;
    401                  #if defined(TWENTYFOUR_BIT)
    402                      y = isqrt64(tmp) >> 26;
    403                  #else
    404                      y = isqrt32(tmp) >> 2;
    405                  #endif
    406                  #if defined(LIMP_MODE_SUPPORT)
    407                      if (operating_mode == OPERATING_MODE_LIMP)
    408                          i = phase_nv->neutral.I_rms_limp_scale_factor;
    409                      else
    410                  #endif
    411                          i = phase_nv->neutral.I_rms_scale_factor;
    412                      test32=y = mul48u_32_16(y, i);
    413                  }
    414              }
    415                  #if defined(PER_SENSOR_PRECALCULATED_PARAMETER_SUPPORT)
    416              phase->metrology.neutral.readings.I_rms = y;
    417                  #endif
    418                  #if defined(DYNAMIC_PHASE_CORRECTION_SUPPORT)
    419              dynamic_phase_correction_neutral(phase, phase_nv, ch);
    420                  #endif
    421              #endif
    422          
    423              if ((phase->status & I_OVERRANGE))
    424              {
    425                  x = (rms_current_t) ~0;
    426              }
    427              else
    428              {
    429                tmp = div_ac_current(phase->metrology.current.dot_prod_logged.I_sq, phase->metrology.current.dot_prod_logged.sample_count);
    430                  if (tmp < phase_nv->current.ac_offset)
    431                  {
    432                      x = 0;
    433                  }
    434                  else
    435                  {
    436          tmp -= phase_nv->current.ac_offset;
    437              #if defined(TWENTYFOUR_BIT)
    438                      
    439                 x =  isqrt64(tmp) >> 26;
    440              #else
    441                      x = isqrt32(tmp) >> 2;
    442              #endif
    443              #if defined(LIMP_MODE_SUPPORT)
    444                      if (operating_mode == OPERATING_MODE_LIMP)
    445                          i = phase_nv->current.I_rms_limp_scale_factor;
    446                      else
    447              #endif
    448                          i = phase_nv->current.I_rms_scale_factor;
    449                      //Changed so can be consistent with F6736's display of parameters
    450                     x = mul48u_32_16(x, i) >> 10;
    451                  }
    452              }
    453                  #if defined(PRECALCULATED_PARAMETER_SUPPORT)
    454                      phase->metrology.current.I_rms = x;
    455                  #endif
    456              #if defined(DYNAMIC_PHASE_CORRECTION_SUPPORT)
    457              dynamic_phase_correction(phase, phase_nv, ch);
    458              #endif
    459              #if defined(LIMP_MODE_SUPPORT)
    460              if (operating_mode == OPERATING_MODE_LIMP)
    461              {
    462                  /* We need to work out for ourselves which is the relevant current
    463                     to use. */
    464                  #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)  &&  defined(POWER_BALANCE_DETECTION_SUPPORT)
    465                  x = test_phase_balance(x, y, PHASE_UNBALANCED_THRESHOLD_CURRENT);
    466                    /* In limp mode we have no way to determine if the phase is reversed,
    467                       so just say it is not. */
    468                  phase->status &= ~PHASE_REVERSED;
    469                  #endif
    470              }
    471              else
    472              #endif
    473              {
    474                  /* The power calculation has provided us which is the appropriate
    475                     current to use. */
    476              #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    477                  if ((phase->status & CURRENT_FROM_NEUTRAL))
    478                         x = y;
    479              #endif
    480              }
    481              return  x;
    482          }
    483          #endif
    484          
    485          
    486          
    487          #if !defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)  &&  defined(IRMS_SUPPORT)
    488          rms_current_t neutral_current(void)
    489          {
    490              rms_current_t x;
    491              int16_t i;
    492              #if defined(TWENTYFOUR_BIT)
    493              int64_t tmp;
    494              #else
    495              int32_t tmp;
    496              #endif
    497          
    498              /* Calculate the RMS current in 1mA increments. Return -1 for overrange
    499                 (i.e. ADC clip). A side effect of this routine is it updates the dynamic
    500                 phase correction settings, based on the newly calculated current. */
    501              if ((neutral.status & I_OVERRANGE))
    502                  return (rms_current_t) ~0;
    503          
    504              tmp = div_ac_current(neutral.metrology.I_sq_accum_logged, neutral.metrology.sample_count_logged);
    505              if (tmp < nv_parms.seg_a.s.neutral.ac_offset)
    506                  return 0;
    507          
    508              #if defined(TWENTYFOUR_BIT)
    509              x = isqrt64(tmp - nv_parms.seg_a.s.neutral.ac_offset) >> 26;
    510              #else
    511              x = isqrt32(tmp - nv_parms.seg_a.s.neutral.ac_offset) >> 2;
    512              #endif
    513              #if defined(LIMP_MODE_SUPPORT)
    514              if (operating_mode == OPERATING_MODE_LIMP)
    515                  i = nv_parms.seg_a.s.neutral.I_rms_limp_scale_factor;
    516              else
    517              #endif
    518                  i = nv_parms.seg_a.s.neutral.I_rms_scale_factor;
    519              x = mul48u_32_16(x, i) >> 10;
    520              return x;
    521          }
    522          #endif
    523          
    524          #if defined(SINGLE_PHASE)
    525          power_t active_power(void)
    526          #else
    527          power_t active_power(struct phase_parms_s *phase, struct phase_nv_parms_s const *phase_nv)
    528          #endif
    529          {
    530              #if defined(TWENTYFOUR_BIT)
    531              int64_t x;
    532              #else
    533              int32_t x;
    534              #endif
    535              #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    536                  #if defined(TWENTYFOUR_BIT)
    537              int64_t y;
    538                  #else
    539              int32_t y;
    540                  #endif
    541              #endif
    542              #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    543              int reversed;
    544              #endif
    545          
    546              if (phase->status & (V_OVERRANGE | I_OVERRANGE))
    547                  return (power_t) ~0;
    548          
    549              /* We can only do real power assessment in full operating mode. */
    550              /* If we have neutral monitoring for a single phase meter, we need to measure
    551                 both power levels, and decide between them. Issues to be assessed here are
    552                 whether one or both leads show reverse power, and whether the power levels
    553                 are balanced. */
    554          #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    555              /* If we find a negative power level we may be genuinely feeding power to the grid,
    556                 or we may be seeing a tamper condition. This is application dependant. */
    557              reversed = FALSE;
    558          #endif
    559          
    560              x = div_ac_power(phase->metrology.current.dot_prod_logged.P_active, phase->metrology.current.dot_prod_logged.sample_count);
    561               x >>= 12;
    562              x = mul48_32_16(x, phase_nv->current.P_scale_factor[0]);
    563              #if defined(PRECALCULATED_PARAMETER_SUPPORT)
    564                  phase->metrology.current.active_power = x;
    565              #endif
    566          #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    567              if (x < 0)
    568              {
    569              #if defined(PHASE_REVERSED_IS_TAMPERING)
    570                  x = -x;
    571              #endif
    572                  phase->status |= I_REVERSED;
    573                  if (x > PHASE_REVERSED_THRESHOLD_POWER)
    574                      reversed = TRUE;
    575              }
    576              else
    577              {
    578                  phase->status &= ~I_REVERSED;   
    579              }
    580          #endif
    581          #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    582              y = div_ac_power(phase->metrology.neutral.dot_prod_logged.P_active, phase->metrology.neutral.dot_prod_logged.sample_count);
    583              y >>= 12;
    584              y = mul48_32_16(y, phase_nv->neutral.P_scale_factor);
    585              #if defined(PER_SENSOR_PRECALCULATED_PARAMETER_SUPPORT)
    586              phase->metrology.neutral.readings.active_power = y;
    587              #endif
    588              #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    589              if (y < 0)
    590              {
    591              #if defined(PHASE_REVERSED_IS_TAMPERING)
    592                  y = -y;
    593              #endif
    594                  phase->status |= I_NEUTRAL_REVERSED;
    595                  if (y > PHASE_REVERSED_THRESHOLD_POWER)
    596                      reversed = TRUE;
    597              }
    598              else
    599              {
    600                  phase->status &= ~I_NEUTRAL_REVERSED;  
    601              }
    602              #endif
    603              #if defined(POWER_BALANCE_DETECTION_SUPPORT)
    604                  #if defined(SINGLE_PHASE)
    605              x = test_phase_balance(x, y, PHASE_UNBALANCED_THRESHOLD_POWER);
    606                  #else
    607              x = test_phase_balance(phase, x, y, PHASE_UNBALANCED_THRESHOLD_POWER);
    608                  #endif
    609              if ((phase->status & PHASE_UNBALANCED))
    610              {
    611                  /* When the phase is unbalanced we only look for reversed current in the 
    612                     lead with the higher current. If we do not impose this restriction, coupling
    613                     through a parasitic CT power supply transformer can cause the reverse condition
    614                     to be raised incorrectly. If there is no parasitic supply this test is probably
    615                     a waste of time. */
    616                  if ((phase->status & CURRENT_FROM_NEUTRAL))
    617                      reversed = phase->status & I_NEUTRAL_REVERSED;
    618                  else
    619                      reversed = phase->status & I_REVERSED;
    620              }
    621              #endif
    622          #endif
    623          #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    624              if ((phase->status & PHASE_REVERSED))
    625              {
    626                  if (!reversed)
    627                  {
    628                      if (--current_reversed <= -PHASE_REVERSED_PERSISTENCE_CHECK)
    629                      {
    630                          phase->status &= ~PHASE_REVERSED;
    631                          current_reversed = 0;
    632                      }
    633                  }
    634                  else
    635                  {
    636                      current_reversed = 0;
    637                  }
    638              }
    639              else
    640              {
    641                  if (reversed)
    642                  {
    643                      if (++current_reversed >= PHASE_REVERSED_PERSISTENCE_CHECK)
    644                      {
    645                          phase->status |= PHASE_REVERSED;
    646                          current_reversed = 0;
    647                      }
    648                  }
    649                  else
    650                  {
    651                      current_reversed = 0;
    652                  }
    653              }
    654          #endif
    655              return x;
    656          }
    657          
    658          #if defined(REACTIVE_POWER_SUPPORT)  &&  defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    659              #if defined(SINGLE_PHASE)
    660          power_t reactive_power(void)
    661              #else
    662          power_t reactive_power(struct phase_parms_s *phase, struct phase_nv_parms_s const *phase_nv)
    663              #endif
    664          {
    665              #if defined(TWENTYFOUR_BIT)
    666              int64_t x;
    667              #else
    668              int32_t x;
    669              #endif
    670              int16_t i;
    671          
    672              if (phase->status & (V_OVERRANGE | I_OVERRANGE))
    673                  return (power_t) ~0;
    674          
    675              /* We can only do real power assessment in full operating mode. */
    676              #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    677              /* If we have neutral monitoring for a single phase meter, we need to use whichever
    678                 channel has been selected by the anti-tamper validation scheme. */
    679              if ((phase->status & CURRENT_FROM_NEUTRAL))
    680              {
    681                  x = div_ac_power(phase->metrology.neutral.dot_prod_logged.P_reactive, phase->metrology.neutral.dot_prod_logged.sample_count);
    682                  i = Q1_15_mul(phase_nv->neutral.P_scale_factor[0], phase->metrology.neutral.quadrature_correction[0].fir_gain);
    683              }
    684              else
    685              #endif
    686              {
    687                  x = div_ac_power(phase->metrology.current.dot_prod_logged.P_reactive, phase->metrology.current.dot_prod_logged.sample_count);
    688                  i = Q1_15_mul(phase_nv->current.P_scale_factor[0], phase->metrology.current.quadrature_correction[0].fir_gain);
    689              }
    690              x >>= 12;
    691              x = mul48_32_16(x, i);
    692              x <<= 2;
    693              #if defined(PER_SENSOR_PRECALCULATED_PARAMETER_SUPPORT)
    694                  #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    695              phase->metrology.neutral.readings.reactive_power = x;
    696                  #endif
    697              phase->metrology.current.readings.reactive_power = x;
    698              #endif
    699              #if defined(PHASE_REVERSED_DETECTION_SUPPORT)
    700              if (x < 0)
    701              {
    702                  #if defined(PHASE_REVERSED_IS_TAMPERING)
    703                  x = -x;
    704                  #endif
    705              }
    706              #endif
    707              return  x;
    708          }
    709          #endif
    710          
    711          #if defined(APPARENT_POWER_SUPPORT)
    712              #if defined(SINGLE_PHASE)
    713          int32_t apparent_power(void)
    714              #else
    715          int32_t apparent_power(struct phase_parms_s *phase, struct phase_nv_parms_s const *phase_nv)
    716              #endif
    717          {
    718              #if defined(REACTIVE_POWER_BY_QUADRATURE_SUPPORT)
    719              int32_t p;
    720              int32_t x;
    721              int shift;
    722          
    723              /* Calculate apparent (VA) power in 0.01W increments */
    724              p = labs(phase->readings.active_power);
    725              x = labs(phase->readings.reactive_power);
    726              /* Justify for optimal accuracy */
    727              shift = 0;
    728              while ((p & 0xFFFFC000)  ||  (x & 0xFFFFC000))
    729              {
    730                  shift++;
    731                  p >>= 1;
    732                  x >>= 1;
    733              }
    734              x = isqrt32(p*p + x*x);
    735              x >>= (16 - shift);
    736              #else
    737              int16_t i;
    738              int32_t x;
    739              int32_t y;
    740          
    741              /* Calculate VA power in 0.01W increments */
    742              x = isqrt32(div_ac_voltage(phase->metrology.dot_prod_logged.V_sq, phase->metrology.dot_prod_logged.sample_count));
    743                  #if defined(LIMP_MODE_SUPPORT)
    744              if (operating_mode == OPERATING_MODE_LIMP)
    745                  i = phase_nv->V_rms_limp_scale_factor;
    746              else
    747                  #endif
    748                  i = phase_nv->V_rms_scale_factor;
    749              x = (x >> 12)*i;
    750              x >>= 14;
    751          
    752                  #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    753              if ((phase->status & CURRENT_FROM_NEUTRAL))
    754              {
    755                      #if defined(TWENTYFOUR_BIT)
    756                  y = isqrt64(div_ac_current(phase->metrology.neutral.dot_prod_logged.I_sq, phase->metrology.dot_prod_logged.sample_count)
    757                            - phase_nv->neutral.ac_offset) >> 36;
    758                      #else
    759                  y = isqrt32(div_ac_current(phase->metrology.neutral.dot_prod_logged.I_sq, phase->metrology.dot_prod_logged.sample_count)
    760                            - phase_nv->neutral.ac_offset) >> 12;
    761                      #endif
    762                      #if defined(LIMP_MODE_SUPPORT)
    763                  if (operating_mode == OPERATING_MODE_LIMP)
    764                      y *= phase_nv->neutral.I_rms_limp_scale_factor;
    765                  else
    766                      #endif
    767                      y *= phase_nv->neutral.I_rms_scale_factor;
    768                  y >>= 14;
    769              }
    770              else
    771              {
    772                  #endif
    773                  #if defined(TWENTYFOUR_BIT)
    774                  y = isqrt64(div_ac_current(phase->metrology.current.dot_prod_logged.I_sq, phase->metrology.current.dot_prod_logged.sample_count)
    775                            - phase_nv->neutral.ac_offset) >> 36;
    776                  #else
    777                  y = isqrt32(div_ac_current(phase->metrology.current.dot_prod_logged.I_sq, phase->metrology.current.dot_prod_logged.sample_count)
    778                            - phase_nv->neutral.ac_offset) >> 12;
    779                  #endif
    780                  #if defined(LIMP_MODE_SUPPORT)
    781                  if (operating_mode == OPERATING_MODE_LIMP)
    782                      y *= phase_nv->current.I_rms_limp_scale_factor;
    783                  else
    784                  #endif
    785                      y *= phase_nv->current.I_rms_scale_factor;
    786                  y >>= 14;
    787                  #if defined(SINGLE_PHASE)  &&  defined(NEUTRAL_MONITOR_SUPPORT)
    788              }
    789                  #endif
    790              x *= y;
    791              x /= 1000;
    792              #endif
    793              return x;
    794          }
    795          #endif
    796          
    797          #if defined(POWER_FACTOR_SUPPORT)
    798          int16_t power_factor()
    799          {
    800              int32_t p;
    801              int32_t x;
    802          
    803              p = labs(phase->readings.active_power);
    804              #if defined(APPARENT_POWER_SUPPORT)
    805                x = labs(phase->readings.apparent_power);
    806              #endif
    807              if (p  &&  x)
    808              {
    809                  /* Justify for optimal accuracy */
    810                  while ((p & 0x40000000) == 0  &&  (x & 0x40000000) == 0)
    811                  {
    812                      p <<= 1;
    813                      x <<= 1;
    814                  }
    815                  x >>= 16;
    816                  p /= x;
    817                  p *= 10000;
    818                  p >>= 16;
    819                  /* Don't let a little imprecision cause strange answers */
    820                  if (p > 10000)
    821                      p = 10000;
    822              }
    823              else
    824              {
    825                  p = 0;
    826              }
    827              /* Use a negative PF to indicate an inductive load */
    828              {
    829                  if (phase->metrology.current.leading < 0)
    830                      p = -p;
    831              }
    832              return p;
    833          }
    834          #endif

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     16   active_power
       16   -> _Div64s
     12   apparent_power
       10   -> isqrt32
     12   current
       12   -> _Div64s
       12   -> isqrt64
      4   frequency
      6   power_factor
     12   reactive_power
       12   -> _Div64s
      4   set_phase_correction
      4   set_sd16_phase_correction
      6   voltage
        4   -> div_sh48
        4   -> isqrt32


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  _A_MPY8
       4  _A_MPYS8
       2  _A_MPYS_L
       2  _A_OP2_L
       8  _A_RES8
       2  _A_SD24BPRE2_L
     288  active_power
     162  apparent_power
     222  current
      74  frequency
     174  power_factor
     220  reactive_power
       2  sd16_locations
      48  set_phase_correction
      44  set_sd16_phase_correction
     118  voltage
       4  xxx
       4  yyy

 
 1 350 bytes in segment CODE
    22 bytes in segment DATA16_AN
     2 bytes in segment DATA16_C
     8 bytes in segment DATA16_Z
 
 1 350 bytes of CODE  memory
     2 bytes of CONST memory
     8 bytes of DATA  memory (+ 22 bytes shared)

Errors: none
Warnings: none
